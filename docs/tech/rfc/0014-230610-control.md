# 14 - Control

**Feature Name**: Control <br />
**Start Date**: 2023-08-09 <br />
**Authors**: Emiliano Bonilla <br />
**Status**: Draft <br />

# 0 - Summary

In this RFC I propose a design for implementing the foundational elements of a control
system in Synnax. While the current Synnax version as of this writing (0.8.0) is capable
of streaming telemetry data for control purposes, it lacks some of the essential
facilities for enabling over the network control; most notably, the ability to negotiate
control over a channel between multiple clients in real-time.

This RFC begins with a discussion of the modifications needed to the Synnax server from
a high-level, structural perspective. As always, there are many ways to implement the
same functionality, and the subsequent sections of this RFC focus on the benefits and
drawbacks of the most promising approaches. Finally, I propose one of these approaches
and discuss it's design in detail.

# 1 - Vocabulary

**Sample** - An arbitrary byte array recorded at a specific point in time. Typically
an event or reading of a sensor or actuator. <br />
**Channel** - A logical collection of samples across a time range. Most often emitted
by a single source. <br />
**Virtual** - Not persisted to disk - usually a channel. <br />
**Leaseholder** - The node in a Synnax cluster responsible for accepting writes for
a specific/channel. <br />
**Non-leased virtual** - A channel that has no leaseholder and is not persisted to
disk. Non-leased virtual channels represent events or signals that can be emitted by
any node in the cluster. <br />

# 2 - Motivation

Implementing a robust control system is one of the final, large features left in the
development of Synnax beta. More details on the motivation for this feature can be
found in the [control PSD](../../product/psd/0002-230610-control.md).

# 3 - Philosophy

# 5 - Detailed Design

## 5.0 - Control Authority

Multi-entity client control requires a method of determining which clients have control
over a channel at any given time. This RFC introduces a new type, `control.Authority`
that is a simple, unsigned 8-bit integer with a few simple rules:

1. A client with a higher authority can prevent a client with a lower authority from
   writing to a channel.
2. A client with a higher authority can take control of a channel from a client with
   a lower authority.
3. A client with higher control authority can release its control over a channel, at
   which point the client with the next highest authority will take control of the
   channel.
4. The behavior of clients with equal authority can be configured at the channel level.
   Channels can allow multiple clients with equal authority to write to them, or they
   can only allow the **first** client to acquire control to write to them.

## 5.1 - The Challenges of Implementing Control Takeover and Release

The most difficult problem in this design involves smoothly transitioning control
between two clients while maintaining data integrity on disk. Imagine a scenario
where we have writer A with control authority 1 that is writing data to a channel.
Writer A has opened a new domain in cesium and is filling it with data. Writer B with
control authority 2 wants to take control of the channel. Writer B opens a domain
starting at the current end of writer A's domain and starts writing data. After writer
B is finished, it commits its domain, closes, and releases control to writer A. If
writer A adds more data, it's domain will overlap with writer B's already committed
domain, and cesium will reject any new commits.

The obvious solution to this problem is to just transfer control of the domain between
writers. This is a good solution, but it has a few drawback. Most notably, Cesium now
needs to be in charge of negotiating control.

# 6 - Working Notes

# 6.0 - Solidifying Typescript Telem Implementations

Implementing and maintaining a separate cache pluto side doesn't make
a lot of sense NGL. We need to think about moving the cache entirely to the client
lib. Problem here is how do we deal with streaming. We need to have a better
understanding of what the live write pipeline looks like. This is particularly
relevant for subset data streaming.
