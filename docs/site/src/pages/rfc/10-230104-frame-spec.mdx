---
title: Telemetry Frame Specification
layout: ../../layouts/MainLayout.astro
---

# 10 - Telemetry Frame Specification and Flight Protocol

**Feature Name**: Telemetry Frame Specification and Flight Protocol <br />
**Start Date** - 2023-01-04 <br />
**Authors** - emilbon99 <br />

# 0 - Summary

The primitive unit of data transfer in Synnax is an array, which contains a collection of
ordered samples for a channel. Moving telemetry across the cluster and to/from clients
using a primitive binary array leaves a lot to be desired. How do we identify the channel
the array belongs to? What is its data type? How do we align it with other arrays?

In this RFC I propose an architecture for wrapping primitive arrays with identifying
meta-data and organizing them into 'frames' of aligned arrays that streamline the telemetry
transfer process.

# 1 - Vocabulary

**Sample** - An arbitrary byte array recorded at a specific point in time. <br />
**Channel** - A name collection of samples across a time range. <br />
**Density** - The number of bytes per sample. <br />
**(Sample/Data) Rate** - The number of samples per second. <br />

# 2 - Array Specification

The current version of Synnax uses a `Segment` type to represent telemetry.
A segment contains a binary data array, a channel key, and a time range. This
format has started to show its limitations. The most obvious issue is that the data type
of the array is unknown. The idea was to find the data type by performing a lookup
on a channel in the aim of removing a few bytes from the segment header. In reality, this
most likely has a negligible impact on performance, as segments typically contain many
thousands of samples or more. On the other hand, the lookups required to find the data
type of a segment do end up beign a performance bottleneck for short lived reads.

The lack of a data type field is just a few of the many overlooked issues with the current
segment format. The new `Array` type aims to restructure and improve the segment format.

## 2.0 - Array Data

The properties of data stored in an array are simple:

1. Channel-tied - Arrays should contain samples for one and only one channel.
2. Continuous - For an array containing samples for a time range x, the samples in the
   array must represent all values in the channel for that time range.
3. Time-ordered - Relatively obvious.
4. Strongly typed - All data in the array is of the same data type, and the data type
   has a fixed density. There are no plans to support variable data types.

All values are encoded in little-endian byte order, with floating point values following
the IEEE 754 standard.

### 2.0.1 - A warning on null and boolean values

I haven't placed extensive though into how nulls or boolean values should be handled.
The current demands for Synnax don't require these features, and they seem to be an easy
addition later on.

## 2.1 - Metadata Fields

This section defines the fields that will be correlated with an `Array`. The actual method
for attaching this information is challening, and is discussed in detail in the next section.

### 2.1.0 - Channel Key

The key for the channel the array belongs to. The telemetry in an array must belong to
one and only one channel.

### 2.1.1 - Time Range

On optioanl time range representing the span of time the array occupies. If provided,
the time range must represent all values in the channel for that time range i.e. it must
be continuous.

### 2.1.2 - Data Type

A string representing the data type of the array. All data types have a fixed density.

## 2.2 - Attaching Meta-Data

The naive approach to adding meta-data is an array header, which contains the
time range, channel key, data type, etc. The problem with this approach lies in maintaining
architectural boundaries between different layers of Synnax. Let's say we were to add a
header field named `key` to the array. What should its data type be? Cesium considers all
channel keys to have a string type, while the distribution layer assigns channel keys
as byte arrays containing identifying information about the channel's lease. Should
we set the key type to `distribution.ChannelKey`? If we do so, our cesium code must be
aware of distribution layer semantics, which is a violation of architectural boundaries.
Our other option would be to define different array types for each layer, and convert
between them. This isn't very dry, and doing complex type conversions whenever we want
to move telemetry between layers is not optimal.

Perhaps the better approach is to define a common array whose meta-data can be shared
across layers, and then move our meta-data somewhere else. This is the approach taken
by Apache Arrow's [Record](https://pkg.go.dev/github.com/apache/arrow/go/arrow@v0.0.0-20211112161151-bc219186db40/array#Record).
Instead of storing meta-data in the array itself, arrow moves it to a separate `Schema`
type which contains identifying information such as the column name (comparable to Synnax's
channel key) outside the array definition itself.

This solution is nice in terms of maintaining a clean architecture, but it also loosens
the connection between data and meta-data. Now we need a supplementary data structure
(like apache arrow's `Record`) that holds information correlating arrays with their meta-data.

The next question to answer is: Should we move all meta-data to a separate data structure,
or should we only move some of it? My answer: some. Some array information is effectively
universal, and will never be layer independent. This includes the data type, density, time
range, and (maybe?) alignment information.

In summary, the approach is **to attach universal meta-data to the array itself, and move
layer-specific meta-data to a separate data structure**.

## 2.3 - Array Definition in Go

```go
package telem

type Array struct {
	// TimeRange is an optional parameter that can be set by the database in order to
	// let the caller know what time range this array occupies.
	TimeRange TimeRange
	// DataType is the data type for the array. Has a fixed density.
	DataType  DataType
	// Data is the telemetry for the array. Each sample is encoded according to a format
	// specified in DataType.
	Data []byte
}
```

## 2.3 - Array Terminology

## 2.1

# 3 - Frame Specification

## 3.0 - Motivation

## 3.1 - General Design and Properties

## 3.1.0 - Alignment

## 3.2 - Specification

## 3.3 - Frame Variants

### 3.3.0 - Weakly Aligned

### 3.3.1 - Strongly Aligned

### 3.3.0 - Horizontal Frames

# Useful for reads.

### 3.3.1 - Vertical Frames

# 4 - Flight Protocol(s)
