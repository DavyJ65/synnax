---
layout: "@/layouts/MainLayout.astro"
---

import { Header } from "@synnaxlabs/pluto";

<Header>
    <Header.Title>Concepts Overview</Header.Title>
</Header>

Synnax is a distributed telemetry engine designed to acquire and store data from, issue
commands to, and process telemetry generated by hardware systems. It scales horizontally,
and can be deployed on edge devices (data acquisition) in highly dynamic environments
with intermittent network connectivity, or in cloud environments (data processing) for
high-performance analysis.

Synnax is a complex distributed system and inherits a hybrid pedigree from hardware-focused
data acquisition systems as well as cloud-native, horizontally scalable databases. We’re
focused on keeping the system simple, and these pages will introduce you to the core
concepts needed to work effectively with a Synnax cluster.

If you’re looking for an introduction to the Synnax internals, look for the Architecture
page.

## Key Components

There are seven core elements to a Synnax deployment:

### Nodes

A node is an individual, running instance of the Synnax executable. The host can be an edge
device, virtual machine, container, or bare metal server. The only requirement is that
it can store data on disk and has an address reachable by other nodes in the cluster.

### Clusters

Nodes join together to form a cluster. The nodes in a cluster collaborate to read, write,
and exchange data. Nodes expose the cluster as a **monolothic data space**, meaning that
a user can query a single node for the entire cluster’s data without being aware of where
that data is actually stored.

### Samples

A sample is a value recorded at a specific point in time. Every sample stored in a
cluster must have an associated timestamp and data type.

### Channels

A channel is a logical collection of samples emitted by or representing the values
of a single source. Practically, a channel holds sensor data as a thermocouple or
pressure transducer readings. It can also hold post-processed results, such as the
noise-filtered signal of another channel. As long as the samples are time-ordered, do
not have duplicates (i.e. no two samples share the same timestamp), and have a consistent
data type, they can be contained in a channel.

### Domains

A domains are continuous, not-overlapping time-partitions of a channel’s data. When writing
to a channel, the user must first define the starting timestamp of a new domain. After
doing so, they are free to write chunks of telemetry. Once finished, they must commit
the domain with an ending timestamp to atomically persist it to the database. If the
range is already occupied, the commit process fails. Domains can be arbitrarily large
or small, and can span from a single sample to hundreds of millions of samples.

### Ranges

A range is a user defined region of a channel's data. Unlike domains, ranges are purely
for categorization and do not affect the structure of a channel's data. Ranges can be
subsections of a domain or span multiple domains. They can also overlap with or contain
other ranges. They typically represent important events (e.g. the moments during impact
in a crash test), or large periods of time (e.g. the collection of all tests for a
particular vehicle model).

### Frames

Finally, a **Frame** is the fundamental unit of data transfer within a Synnax cluster.
It's comparable to a `pandas.DataFrame` in Python, or a `data.frame` in R. It is a table
like structure, where each column holds a subset of the data for a channel. To write data
to channels, the user assembles a frame (or series of frames) and provides them to the
database. The opposite pattern applies for reads; the caller provides a set of channels
and a time range, and receives one or more frames in response.

## Synnax as a Spreadsheet

The simplest way to understand the data layout of a Synnax cluster is to view it as a single, time-ordered, and very large spreadsheet.

## Further Reading
