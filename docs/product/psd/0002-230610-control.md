# 2 - Control

**Feature Name**: Control <br />
**Status**: Draft <br />
**Start Date**: 2023-06-10 <br />
**Authors**: Emiliano Bonilla <br />

# 0 - Summary

# 1 - Problem Statement

# 2 - User Research Summary

User research is the driving force behind the design of this feature set. All of our
user research findings can be
found [here](https://drive.google.com/drive/u/0/folders/13Vc-G5CNzCwhxx9vNsHJLECK9Mrqz0if).
As this is a public document, we've anonymized and summarized our findings below.

## 2.0 - Implementing a new control system is difficult and risky

Hardware control systems have a different demands for reliability than other software. They
can control expensive, dangerous, and delicate equipment, where the cost of hardware
failure can be in the hundreds of millions of dollars or result in the loss of human
life. Naturally, developing new version of such systems is risky, making adoption a
difficult process.

As one user put it: "You should never think, 'I wish I hand't automated this'". The most
important characteristic of current control systems is that they never prevent the user
from gaining manual control in a dangerous situation. While, in some situations, letting
the user take manual control can also be risky, with new control systems, it's preferrable
to give authority to the operator over the software.

As infrastructure gets more expensive and/or dangerous to human life, the standards for
control software dramatically steepen. Certification processes and multi-modular
redundancy become commonplace.

## 2.1 - Users want to do a lot of things at once

Even small hardware systems can have many process; various automated analysis
scripts, conditional abort sequences, auto sequences, and manual control can coexist
to enable effective operations. These operations must concurrently interact with the
system in harmony, and exchange of control must be reliable.

These processes often require control authority at the channel level. For example, two
pressurization sequences for separate tanks must be able to command different valves at
the same time. In addition, processes like abort sequences must be able to seize control
at any time. Our users need an intuitive way of defining under what conditions a process
has control authority over a (specific region) of the system.

## 2.2 - Operations/test engineers want to implement auto sequences

Modern hardware operations are more cross-disciplinary than ever. Smaller, highly
interactive teams are doing more with less. Part of this transition involves
enabling test/operations engineers to write control sequences themselves. Traditional
control sequence development demands constant communication between the test engineers
who define what the steps should look like and software/instrumentation engineers who
know how to implement the sequence itself. Inefficiencies in this cycle mean that test
engineers are left waiting while software engineers are overwhelmed and cannot focus
on the core tasks at hand.

Enabling test engineers to write control sequences removes this inefficiency entirely;
both sides of the process are free to focus on other, more important areas of work. As
one control engineer puts it, "The more people that are knowledgeable about your system,
the less time your DCS engineers need to spend time making minor changes. Empowering
test engineers empowers controls engineers."

The primary challenge is developing a language simple and semantic enough that less
experience programmers can start developing with quickly.

## 2.3 - Manual and programmatic control coexist

## 2.4 - Users want access to meta-data in their control sequences

## 2.5 - Concurrent control authority and reliability are essential

## 2.6 - There are multiple control paradigms

# 3 - Strategy
